"""
Ising matrix-product-state engine built on top of Qiskit Aer.

This module focuses solely on constructing the transverse-field Ising Hamiltonian,
configuring the GPU-backed MPS backend, and providing helper utilities for
building / executing time-evolution circuits.
"""

from __future__ import annotations

from typing import Union

import numpy as np
from qiskit import QuantumCircuit, transpile
from qiskit.circuit.library import PauliEvolutionGate
from qiskit.quantum_info import SparsePauliOp
from qiskit_aer import AerSimulator


class IsingMPSEngine:
    """Engine for time-evolving the 1D transverse-field Ising model with an MPS backend."""

    def __init__(
        self,
        num_sites: int,
        interaction_strength: float,
        transverse_field: float,
        mps_bond_dim: int = 128,
    ) -> None:
        if num_sites < 2:
            raise ValueError("num_sites must be at least 2 to define nearest-neighbor couplings.")

        self.num_sites = num_sites
        self.interaction_strength = interaction_strength
        self.transverse_field = transverse_field
        self.longitudinal_field = 0.0  # Specs reserve longitudinal terms for other modules.
        self.mps_bond_dim = mps_bond_dim

        self.hamiltonian = self._build_hamiltonian()
        self.backend = self._build_backend()

    def _build_hamiltonian(self) -> SparsePauliOp:
        """Construct the Ising Hamiltonian (Eq. 5) as a SparsePauliOp."""

        pauli_terms: list[str] = []
        coeffs: list[complex] = []

        # Longitudinal ZZ interactions (periodic boundary conditions).
        for site in range(self.num_sites):
            neighbor = (site + 1) % self.num_sites
            term = ["I"] * self.num_sites
            term[site] = "Z"
            term[neighbor] = "Z"
            pauli_terms.append("".join(reversed(term)))
            coeffs.append(-self.interaction_strength)

        # Transverse X field.
        for site in range(self.num_sites):
            term = ["I"] * self.num_sites
            term[site] = "X"
            pauli_terms.append("".join(reversed(term)))
            coeffs.append(-self.transverse_field)

        # Optional longitudinal Z field placeholder (kept for completeness).
        if not np.isclose(self.longitudinal_field, 0.0):
            for site in range(self.num_sites):
                term = ["I"] * self.num_sites
                term[site] = "Z"
                pauli_terms.append("".join(reversed(term)))
                coeffs.append(-self.longitudinal_field)

        return SparsePauliOp.from_list(list(zip(pauli_terms, coeffs)))

    def _build_backend(self) -> AerSimulator:
        """Instantiate the GPU-backed MPS simulator, falling back to CPU if needed."""

        base_kwargs = {"method": "matrix_product_state", "device": "GPU"}

        try:
            backend = AerSimulator(**base_kwargs)
        except Exception:
            # Fallback for environments without GPU support.
            backend = AerSimulator(method="matrix_product_state")

        try:
            backend.set_options(matrix_product_state_max_bond_dimension=self.mps_bond_dim)
        except Exception:
            # Older Aer versions may not expose this option; ignore gracefully.
            pass

        return backend

    def build_time_evolution_gate(self, time_step: float) -> PauliEvolutionGate:
        """Return a single-step time-evolution gate generated by the Hamiltonian."""

        if time_step <= 0:
            raise ValueError("time_step must be positive.")
        return PauliEvolutionGate(self.hamiltonian, time=time_step)

    def evolve_circuit(self, circuit: QuantumCircuit, time_step: float, num_steps: int) -> QuantumCircuit:
        """Append the time-evolution gate `num_steps` times and return the updated circuit."""

        if num_steps <= 0:
            raise ValueError("num_steps must be positive.")

        evo_gate = self.build_time_evolution_gate(time_step)
        evolved = circuit.copy()
        for _ in range(num_steps):
            evolved.append(evo_gate, evolved.qubits)
        return evolved

    def run_circuit(self, circuit: QuantumCircuit, shots: int = 0) -> Union[dict, np.ndarray]:
        """
        Transpile and execute the supplied circuit on the configured backend.

        Returns a final statevector when `shots == 0`, otherwise returns measurement counts.
        """

        run_circuit = circuit.copy()
        meas_shots = shots if shots and shots > 0 else None

        if meas_shots is None:
            run_circuit.save_statevector()

        transpiled = transpile(run_circuit, self.backend)

        try:
            job = self.backend.run(transpiled, shots=meas_shots)
            result = job.result()
        except RuntimeError as exc:
            if "device \"GPU\" is not supported" not in str(exc):
                raise

            # Rebuild backend on CPU and retry once.
            self.backend = AerSimulator(method="matrix_product_state")
            try:
                self.backend.set_options(matrix_product_state_max_bond_dimension=self.mps_bond_dim)
            except Exception:
                pass

            transpiled = transpile(run_circuit, self.backend)
            job = self.backend.run(transpiled, shots=meas_shots)
            result = job.result()

        if meas_shots is None:
            data = result.data(0)
            return data["statevector"]
        return result.get_counts()

